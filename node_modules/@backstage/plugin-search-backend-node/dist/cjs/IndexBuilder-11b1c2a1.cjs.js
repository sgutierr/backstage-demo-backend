'use strict';

var stream = require('stream');

class Scheduler {
  constructor(options) {
    this.logger = options.logger;
    this.schedule = {};
    this.abortControllers = [];
    this.isRunning = false;
  }
  /**
   * Adds each task and interval to the schedule.
   * When running the tasks, the scheduler waits at least for the time specified
   * in the interval once the task was completed, before running it again.
   */
  addToSchedule(options) {
    const { id, task, scheduledRunner } = options;
    if (this.isRunning) {
      throw new Error(
        "Cannot add task to schedule that has already been started."
      );
    }
    if (this.schedule[id]) {
      throw new Error(`Task with id ${id} already exists.`);
    }
    this.schedule[id] = { task, scheduledRunner };
  }
  /**
   * Starts the scheduling process for each task
   */
  start() {
    this.logger.info("Starting all scheduled search tasks.");
    this.isRunning = true;
    Object.keys(this.schedule).forEach((id) => {
      const abortController = new AbortController();
      this.abortControllers.push(abortController);
      const { task, scheduledRunner } = this.schedule[id];
      scheduledRunner.run({
        id,
        fn: task,
        signal: abortController.signal
      });
    });
  }
  /**
   * Stop all scheduled tasks.
   */
  stop() {
    this.logger.info("Stopping all scheduled search tasks.");
    for (const abortController of this.abortControllers) {
      abortController.abort();
    }
    this.abortControllers = [];
    this.isRunning = false;
  }
}

class IndexBuilder {
  constructor(options) {
    this.collators = {};
    this.decorators = {};
    this.documentTypes = {};
    this.logger = options.logger;
    this.searchEngine = options.searchEngine;
  }
  /**
   * Responsible for returning the registered search engine.
   */
  getSearchEngine() {
    return this.searchEngine;
  }
  /**
   * Responsible for returning the registered document types.
   */
  getDocumentTypes() {
    return this.documentTypes;
  }
  /**
   * Makes the index builder aware of a collator that should be executed at the
   * given refresh interval.
   */
  addCollator(options) {
    const { factory, schedule } = options;
    this.logger.info(
      `Added ${factory.constructor.name} collator factory for type ${factory.type}`
    );
    this.collators[factory.type] = {
      factory,
      schedule
    };
    this.documentTypes[factory.type] = {
      visibilityPermission: factory.visibilityPermission
    };
  }
  /**
   * Makes the index builder aware of a decorator. If no types are provided on
   * the decorator, it will be applied to documents from all known collators,
   * otherwise it will only be applied to documents of the given types.
   */
  addDecorator(options) {
    const { factory } = options;
    const types = factory.types || ["*"];
    this.logger.info(
      `Added decorator ${factory.constructor.name} to types ${types.join(
        ", "
      )}`
    );
    types.forEach((type) => {
      if (this.decorators.hasOwnProperty(type)) {
        this.decorators[type].push(factory);
      } else {
        this.decorators[type] = [factory];
      }
    });
  }
  /**
   * Compiles collators and decorators into tasks, which are added to a
   * scheduler returned to the caller.
   */
  async build() {
    const scheduler = new Scheduler({
      logger: this.logger
    });
    Object.keys(this.collators).forEach((type) => {
      const taskLogger = this.logger.child({ documentType: type });
      scheduler.addToSchedule({
        id: `search_index_${type.replace("-", "_").toLocaleLowerCase("en-US")}`,
        scheduledRunner: this.collators[type].schedule,
        task: async () => {
          const collator = await this.collators[type].factory.getCollator();
          taskLogger.info(
            `Collating documents for ${type} via ${this.collators[type].factory.constructor.name}`
          );
          const decorators = await Promise.all(
            (this.decorators["*"] || []).concat(this.decorators[type] || []).map(async (factory) => {
              const decorator = await factory.getDecorator();
              taskLogger.info(
                `Attached decorator via ${factory.constructor.name} to ${type} index pipeline.`
              );
              return decorator;
            })
          );
          const indexer = await this.searchEngine.getIndexer(type);
          return new Promise((resolve, reject) => {
            stream.pipeline(
              [collator, ...decorators, indexer],
              (error) => {
                if (error) {
                  taskLogger.error(
                    `Collating documents for ${type} failed: ${error}`
                  );
                  reject(error);
                } else {
                  taskLogger.info(`Collating documents for ${type} succeeded`);
                  resolve();
                }
              }
            );
          });
        }
      });
    });
    return {
      scheduler
    };
  }
}

exports.IndexBuilder = IndexBuilder;
exports.Scheduler = Scheduler;
//# sourceMappingURL=IndexBuilder-11b1c2a1.cjs.js.map
