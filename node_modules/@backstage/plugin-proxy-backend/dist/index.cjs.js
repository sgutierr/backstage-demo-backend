'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Router = require('express-promise-router');
var httpProxyMiddleware = require('http-proxy-middleware');
var backendCommon = require('@backstage/backend-common');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);

const safeForwardHeaders = [
  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header
  "cache-control",
  "content-language",
  "content-length",
  "content-type",
  "expires",
  "last-modified",
  "pragma",
  // host is overridden by default. if changeOrigin is configured to false,
  // we assume this is a intentional and should also be forwarded.
  "host",
  // other headers that we assume to be ok
  "accept",
  "accept-language",
  "user-agent"
];
function buildMiddleware(pathPrefix, logger, route, config, reviveConsumedRequestBodies) {
  var _a;
  const fullConfig = typeof config === "string" ? { target: config } : { ...config };
  if (typeof fullConfig.target !== "string") {
    throw new Error(`Proxy target must be a string`);
  }
  try {
    new URL(fullConfig.target);
  } catch {
    throw new Error(
      `Proxy target is not a valid URL: ${(_a = fullConfig.target) != null ? _a : ""}`
    );
  }
  if (fullConfig.pathRewrite === void 0) {
    let routeWithSlash = route.endsWith("/") ? route : `${route}/`;
    if (!pathPrefix.endsWith("/") && !routeWithSlash.startsWith("/")) {
      routeWithSlash = `/${routeWithSlash}`;
    } else if (pathPrefix.endsWith("/") && routeWithSlash.startsWith("/")) {
      routeWithSlash = routeWithSlash.substring(1);
    }
    fullConfig.pathRewrite = {
      [`^${pathPrefix}${routeWithSlash}?`]: "/"
    };
  }
  if (fullConfig.changeOrigin === void 0) {
    fullConfig.changeOrigin = true;
  }
  fullConfig.logProvider = () => logger;
  fullConfig.logLevel = "debug";
  const requestHeaderAllowList = new Set(
    [
      // allow all safe headers
      ...safeForwardHeaders,
      // allow all headers that are set by the proxy
      ...fullConfig.headers && Object.keys(fullConfig.headers) || [],
      // allow all configured headers
      ...fullConfig.allowedHeaders || []
    ].map((h) => h.toLocaleLowerCase())
  );
  const filter = (_pathname, req) => {
    var _a2, _b;
    const headerNames = Object.keys(req.headers);
    headerNames.forEach((h) => {
      if (!requestHeaderAllowList.has(h.toLocaleLowerCase())) {
        delete req.headers[h];
      }
    });
    return (_b = (_a2 = fullConfig == null ? void 0 : fullConfig.allowedMethods) == null ? void 0 : _a2.includes(req.method)) != null ? _b : true;
  };
  filter.toString = () => route;
  const responseHeaderAllowList = new Set(
    [
      // allow all safe headers
      ...safeForwardHeaders,
      // allow all configured headers
      ...fullConfig.allowedHeaders || []
    ].map((h) => h.toLocaleLowerCase())
  );
  fullConfig.onProxyRes = (proxyRes) => {
    const headerNames = Object.keys(proxyRes.headers);
    headerNames.forEach((h) => {
      if (!responseHeaderAllowList.has(h.toLocaleLowerCase())) {
        delete proxyRes.headers[h];
      }
    });
  };
  if (reviveConsumedRequestBodies) {
    fullConfig.onProxyReq = httpProxyMiddleware.fixRequestBody;
  }
  return httpProxyMiddleware.createProxyMiddleware(filter, fullConfig);
}
async function createRouter(options) {
  var _a;
  const router = Router__default["default"]();
  let currentRouter = Router__default["default"]();
  const externalUrl = await options.discovery.getExternalBaseUrl("proxy");
  const { pathname: pathPrefix } = new URL(externalUrl);
  const proxyConfig = (_a = options.config.getOptional("proxy")) != null ? _a : {};
  configureMiddlewares(options, currentRouter, pathPrefix, proxyConfig);
  router.use((...args) => currentRouter(...args));
  if (options.config.subscribe) {
    let currentKey = JSON.stringify(proxyConfig);
    options.config.subscribe(() => {
      var _a2;
      const newProxyConfig = (_a2 = options.config.getOptional("proxy")) != null ? _a2 : {};
      const newKey = JSON.stringify(newProxyConfig);
      if (currentKey !== newKey) {
        currentKey = newKey;
        currentRouter = Router__default["default"]();
        configureMiddlewares(
          options,
          currentRouter,
          pathPrefix,
          newProxyConfig
        );
      }
    });
  }
  return router;
}
function configureMiddlewares(options, router, pathPrefix, proxyConfig) {
  Object.entries(proxyConfig).forEach(([route, proxyRouteConfig]) => {
    try {
      router.use(
        route,
        buildMiddleware(
          pathPrefix,
          options.logger,
          route,
          proxyRouteConfig,
          options.reviveConsumedRequestBodies
        )
      );
    } catch (e) {
      if (options.skipInvalidProxies) {
        options.logger.warn(`skipped configuring ${route} due to ${e.message}`);
      } else {
        throw e;
      }
    }
  });
}

const proxyPlugin = backendPluginApi.createBackendPlugin(
  (options) => ({
    pluginId: "proxy",
    register(env) {
      env.registerInit({
        deps: {
          config: backendPluginApi.coreServices.config,
          discovery: backendPluginApi.coreServices.discovery,
          logger: backendPluginApi.coreServices.logger,
          httpRouter: backendPluginApi.coreServices.httpRouter
        },
        async init({ config, discovery, logger, httpRouter }) {
          httpRouter.use(
            await createRouter({
              config,
              discovery,
              logger: backendCommon.loggerToWinstonLogger(logger),
              skipInvalidProxies: options == null ? void 0 : options.skipInvalidProxies,
              reviveConsumedRequestBodies: options == null ? void 0 : options.reviveConsumedRequestBodies
            })
          );
        }
      });
    }
  })
);

exports.createRouter = createRouter;
exports.proxyPlugin = proxyPlugin;
//# sourceMappingURL=index.cjs.js.map
