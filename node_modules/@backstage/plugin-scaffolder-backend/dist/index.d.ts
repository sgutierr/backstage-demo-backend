/// <reference types="node" />
import * as _backstage_plugin_scaffolder_node from '@backstage/plugin-scaffolder-node';
import { TemplateAction as TemplateAction$1, TaskSecrets as TaskSecrets$1, ActionContext as ActionContext$1 } from '@backstage/plugin-scaffolder-node';
import * as _backstage_types from '@backstage/types';
import { JsonValue, HumanDuration, JsonObject, Observable } from '@backstage/types';
import { ScmIntegrations, ScmIntegrationRegistry, GithubCredentialsProvider } from '@backstage/integration';
import { CatalogApi } from '@backstage/catalog-client';
import { UrlReader, PluginDatabaseManager } from '@backstage/backend-common';
import { Config } from '@backstage/config';
import { Duration } from 'luxon';
import { Octokit } from 'octokit';
import { createPullRequest } from 'octokit-plugin-create-pull-request';
import { SpawnOptionsWithoutStdio } from 'child_process';
import { Writable } from 'stream';
import { Knex } from 'knex';
import * as _backstage_plugin_scaffolder_common from '@backstage/plugin-scaffolder-common';
import { TaskSpec, TemplateEntityStepV1beta3, TemplateParametersV1beta3 } from '@backstage/plugin-scaffolder-common';
import { Logger } from 'winston';
import { PermissionEvaluator, PermissionRuleParams } from '@backstage/plugin-permission-common';
import { PluginTaskScheduler } from '@backstage/backend-tasks';
import { RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, RESOURCE_TYPE_SCAFFOLDER_ACTION } from '@backstage/plugin-scaffolder-common/alpha';
import express from 'express';
import { IdentityApi } from '@backstage/plugin-auth-node';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { Entity } from '@backstage/catalog-model';
import { CatalogProcessor, CatalogProcessorEmit } from '@backstage/plugin-catalog-node';
import { LocationSpec } from '@backstage/plugin-catalog-common';
import * as jsonschema from 'jsonschema';
import * as zod from 'zod';

/**
 * Registers entities from a catalog descriptor file in the workspace into the software catalog.
 * @public
 */
declare function createCatalogRegisterAction(options: {
    catalogClient: CatalogApi;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    catalogInfoUrl: string;
    optional?: boolean | undefined;
} | {
    repoContentsUrl: string;
    catalogInfoPath?: string | undefined;
    optional?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Writes a catalog descriptor file containing the provided entity to a path in the workspace.
 * @public
 */
declare function createCatalogWriteAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    entity: Record<string, any>;
    filePath?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Returns entity or entities from the catalog by entity reference(s).
 *
 * @public
 */
declare function createFetchCatalogEntityAction(options: {
    catalogClient: CatalogApi;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    entityRef?: string | undefined;
    entityRefs?: string[] | undefined;
    optional?: boolean | undefined;
    defaultKind?: string | undefined;
    defaultNamespace?: string | undefined;
}, {
    entity?: any;
    entities?: any[] | undefined;
}>;

/** @public */
type TemplateFilter = (...args: JsonValue[]) => JsonValue | undefined;
/** @public */
type TemplateGlobal = ((...args: JsonValue[]) => JsonValue | undefined) | JsonValue;

/**
 * The options passed to {@link createBuiltinActions}
 * @public
 */
interface CreateBuiltInActionsOptions {
    /**
     * The {@link @backstage/backend-common#UrlReader} interface that will be used in the default actions.
     */
    reader: UrlReader;
    /**
     * The {@link @backstage/integrations#ScmIntegrations} that will be used in the default actions.
     */
    integrations: ScmIntegrations;
    /**
     * The {@link @backstage/catalog-client#CatalogApi} that will be used in the default actions.
     */
    catalogClient: CatalogApi;
    /**
     * The {@link @backstage/config#Config} that will be used in the default actions.
     */
    config: Config;
    /**
     * Additional custom filters that will be passed to the nunjucks template engine for use in
     * Template Manifests and also template skeleton files when using `fetch:template`.
     */
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}
/**
 * A function to generate create a list of default actions that the scaffolder provides.
 * Is called internally in the default setup, but can be used when adding your own actions or overriding the default ones
 *
 * @public
 * @returns A list of actions that can be used in the scaffolder
 */
declare const createBuiltinActions: (options: CreateBuiltInActionsOptions) => TemplateAction$1[];

/**
 * Writes a message into the log or lists all files in the workspace
 *
 * @remarks
 *
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * @public
 */
declare function createDebugLogAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    message?: string | undefined;
    listWorkspace?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Waits for a certain period of time.
 *
 * @remarks
 *
 * This task is useful to give some waiting time for manual intervention.
 * Has to be used in a combination with other actions.
 *
 * @public
 */
declare function createWaitAction(options?: {
    maxWaitTime?: Duration | HumanDuration;
}): _backstage_plugin_scaffolder_node.TemplateAction<HumanDuration, _backstage_types.JsonObject>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainFileAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
}, _backstage_types.JsonObject>;

/**
 * Downloads a skeleton, templates variables into file and directory names and content.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 *
 * @public
 */
declare function createFetchTemplateAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
    values: any;
    templateFileExtension?: string | boolean | undefined;
    /**
     * @deprecated This field is deprecated in favor of copyWithoutTemplating.
     */
    copyWithoutRender?: string[] | undefined;
    copyWithoutTemplating?: string[] | undefined;
    cookiecutterCompat?: boolean | undefined;
    replace?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 */
declare function fetchContents(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    baseUrl?: string;
    fetchUrl?: string;
    outputPath: string;
}): Promise<void>;

/**
 * Creates new action that enables deletion of files and directories in the workspace.
 * @public
 */
declare const createFilesystemDeleteAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: string[];
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that allows renames of files and directories in the workspace.
 * @public
 */
declare const createFilesystemRenameAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: Array<{
        from: string;
        to: string;
        overwrite?: boolean;
    }>;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Azure.
 * @public
 */
declare function createPublishAzureAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    defaultBranch?: string | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Bitbucket.
 * @public
 * @deprecated in favor of createPublishBitbucketCloudAction and createPublishBitbucketServerAction
 */
declare function createPublishBitbucketAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    defaultBranch?: string | undefined;
    repoVisibility?: "private" | "public" | undefined;
    sourcePath?: string | undefined;
    enableLFS?: boolean | undefined;
    token?: string | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Bitbucket Cloud.
 * @public
 */
declare function createPublishBitbucketCloudAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    defaultBranch?: string | undefined;
    repoVisibility?: "private" | "public" | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Bitbucket Server.
 * @public
 */
declare function createPublishBitbucketServerAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    defaultBranch?: string | undefined;
    repoVisibility?: "private" | "public" | undefined;
    sourcePath?: string | undefined;
    enableLFS?: boolean | undefined;
    token?: string | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to a Gerrit instance.
 * @public
 */
declare function createPublishGerritAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description: string;
    defaultBranch?: string | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
    sourcePath?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that creates a Gerrit review
 * @public
 */
declare function createPublishGerritReviewAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    branch?: string | undefined;
    sourcePath?: string | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to GitHub.
 *
 * @public
 */
declare function createPublishGithubAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    homepage?: string | undefined;
    access?: string | undefined;
    defaultBranch?: string | undefined;
    protectDefaultBranch?: boolean | undefined;
    protectEnforceAdmins?: boolean | undefined;
    deleteBranchOnMerge?: boolean | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
    allowRebaseMerge?: boolean | undefined;
    allowSquashMerge?: boolean | undefined;
    squashMergeCommitTitle?: "PR_TITLE" | "COMMIT_OR_PR_TITLE" | undefined;
    squashMergeCommitMessage?: "PR_BODY" | "COMMIT_MESSAGES" | "BLANK" | undefined;
    allowMergeCommit?: boolean | undefined;
    allowAutoMerge?: boolean | undefined;
    sourcePath?: string | undefined;
    bypassPullRequestAllowances?: {
        users?: string[];
        teams?: string[];
        apps?: string[];
    } | undefined;
    requiredApprovingReviewCount?: number | undefined;
    restrictions?: {
        users: string[];
        teams: string[];
        apps?: string[];
    } | undefined;
    requireCodeOwnerReviews?: boolean | undefined;
    dismissStaleReviews?: boolean | undefined;
    requiredStatusCheckContexts?: string[] | undefined;
    requireBranchesToBeUpToDate?: boolean | undefined;
    requiredConversationResolution?: boolean | undefined;
    repoVisibility?: "internal" | "private" | "public" | undefined;
    collaborators?: ({
        user: string;
        access: string;
    } | {
        team: string;
        access: string;
    } | {
        /** @deprecated This field is deprecated in favor of team */
        username: string;
        access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
    })[] | undefined;
    hasProjects?: boolean | undefined;
    hasWiki?: boolean | undefined;
    hasIssues?: boolean | undefined;
    token?: string | undefined;
    topics?: string[] | undefined;
    requiredCommitSigning?: boolean | undefined;
}, _backstage_types.JsonObject>;

/** @public */
type OctokitWithPullRequestPluginClient = Octokit & {
    createPullRequest(options: createPullRequest.Options): Promise<{
        data: {
            html_url: string;
            number: number;
        };
    } | null>;
};
/**
 * The options passed to the client factory function.
 * @public
 */
type CreateGithubPullRequestClientFactoryInput = {
    integrations: ScmIntegrationRegistry;
    githubCredentialsProvider?: GithubCredentialsProvider;
    host: string;
    owner: string;
    repo: string;
    token?: string;
};
/**
 * The options passed to {@link createPublishGithubPullRequestAction} method
 * @public
 */
interface CreateGithubPullRequestActionOptions {
    /**
     * An instance of {@link @backstage/integration#ScmIntegrationRegistry} that will be used in the action.
     */
    integrations: ScmIntegrationRegistry;
    /**
     * An instance of {@link @backstage/integration#GithubCredentialsProvider} that will be used to get credentials for the action.
     */
    githubCredentialsProvider?: GithubCredentialsProvider;
    /**
     * A method to return the Octokit client with the Pull Request Plugin.
     */
    clientFactory?: (input: CreateGithubPullRequestClientFactoryInput) => Promise<OctokitWithPullRequestPluginClient>;
}
/**
 * Creates a Github Pull Request action.
 * @public
 */
declare const createPublishGithubPullRequestAction: (options: CreateGithubPullRequestActionOptions) => _backstage_plugin_scaffolder_node.TemplateAction<{
    title: string;
    branchName: string;
    description: string;
    repoUrl: string;
    draft?: boolean | undefined;
    targetPath?: string | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
    reviewers?: string[] | undefined;
    teamReviewers?: string[] | undefined;
    commitMessage?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to GitLab.
 *
 * @public
 */
declare function createPublishGitlabAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    defaultBranch?: string | undefined;
    repoVisibility?: "internal" | "private" | "public" | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
    setUserAsOwner?: boolean | undefined;
    topics?: string[] | undefined;
}, _backstage_types.JsonObject>;

/**
 * Create a new action that creates a gitlab merge request.
 *
 * @public
 */
declare const createPublishGitlabMergeRequestAction: (options: {
    integrations: ScmIntegrationRegistry;
}) => _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    title: string;
    description: string;
    branchName: string;
    sourcePath?: string | undefined;
    targetPath?: string | undefined;
    token?: string | undefined;
    commitAction?: "update" | "delete" | "create" | undefined;
    /** @deprecated projectID passed as query parameters in the repoUrl */
    projectid?: string | undefined;
    removeSourceBranch?: boolean | undefined;
    assignee?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that dispatches a GitHub Action workflow for a given branch or tag.
 * @public
 */
declare function createGithubActionsDispatchAction(options: {
    integrations: ScmIntegrations;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    workflowId: string;
    branchOrTagName: string;
    workflowInputs?: {
        [key: string]: string;
    } | undefined;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Adds labels to a pull request or issue on GitHub
 * @public
 */
declare function createGithubIssuesLabelAction(options: {
    integrations: ScmIntegrationRegistry;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    number: number;
    labels: string[];
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository
 *
 * @public
 */
declare function createGithubRepoCreateAction(options: {
    integrations: ScmIntegrationRegistry;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    homepage?: string | undefined;
    access?: string | undefined;
    deleteBranchOnMerge?: boolean | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
    allowRebaseMerge?: boolean | undefined;
    allowSquashMerge?: boolean | undefined;
    squashMergeCommitTitle?: "PR_TITLE" | "COMMIT_OR_PR_TITLE" | undefined;
    squashMergeCommitMessage?: "PR_BODY" | "COMMIT_MESSAGES" | "BLANK" | undefined;
    allowMergeCommit?: boolean | undefined;
    allowAutoMerge?: boolean | undefined;
    requireCodeOwnerReviews?: boolean | undefined;
    bypassPullRequestAllowances?: {
        users?: string[] | undefined;
        teams?: string[] | undefined;
        apps?: string[] | undefined;
    } | undefined;
    requiredApprovingReviewCount?: number | undefined;
    restrictions?: {
        users: string[];
        teams: string[];
        apps?: string[] | undefined;
    } | undefined;
    requiredStatusCheckContexts?: string[] | undefined;
    requireBranchesToBeUpToDate?: boolean | undefined;
    requiredConversationResolution?: boolean | undefined;
    repoVisibility?: "internal" | "private" | "public" | undefined;
    collaborators?: ({
        user: string;
        access: string;
    } | {
        team: string;
        access: string;
    } | {
        /** @deprecated This field is deprecated in favor of team */
        username: string;
        access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
    })[] | undefined;
    hasProjects?: boolean | undefined;
    hasWiki?: boolean | undefined;
    hasIssues?: boolean | undefined;
    token?: string | undefined;
    topics?: string[] | undefined;
    requireCommitSigning?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to GitHub.
 *
 * @public
 */
declare function createGithubRepoPushAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    description?: string | undefined;
    defaultBranch?: string | undefined;
    protectDefaultBranch?: boolean | undefined;
    protectEnforceAdmins?: boolean | undefined;
    gitCommitMessage?: string | undefined;
    gitAuthorName?: string | undefined;
    gitAuthorEmail?: string | undefined;
    requireCodeOwnerReviews?: boolean | undefined;
    dismissStaleReviews?: boolean | undefined;
    bypassPullRequestAllowances?: {
        users?: string[];
        teams?: string[];
        apps?: string[];
    } | undefined;
    requiredApprovingReviewCount?: number | undefined;
    restrictions?: {
        users: string[];
        teams: string[];
        apps?: string[];
    } | undefined;
    requiredStatusCheckContexts?: string[] | undefined;
    requireBranchesToBeUpToDate?: boolean | undefined;
    requiredConversationResolution?: boolean | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
    requiredCommitSigning?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates new action that creates a webhook for a repository on GitHub.
 * @public
 */
declare function createGithubWebhookAction(options: {
    integrations: ScmIntegrationRegistry;
    defaultWebhookSecret?: string;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    webhookUrl: string;
    webhookSecret?: string | undefined;
    events?: string[] | undefined;
    active?: boolean | undefined;
    contentType?: "form" | "json" | undefined;
    insecureSsl?: boolean | undefined;
    token?: string | undefined;
}, _backstage_types.JsonObject>;

/** @public */
type RunCommandOptions = {
    /** command to run */
    command: string;
    /** arguments to pass the command */
    args: string[];
    /** options to pass to spawn */
    options?: SpawnOptionsWithoutStdio;
    /** stream to capture stdout and stderr output */
    logStream?: Writable;
};
/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 */
declare const executeShellCommand: (options: RunCommandOptions) => Promise<void>;

/**
 * Registry of all registered template actions.
 * @public
 */
declare class TemplateActionRegistry {
    private readonly actions;
    register(action: TemplateAction$1): void;
    get(actionId: string): TemplateAction$1;
    list(): TemplateAction$1[];
}

/**
 * The status of each step of the Task
 *
 * @public
 */
type TaskStatus = 'cancelled' | 'completed' | 'failed' | 'open' | 'processing';
/**
 * The state of a completed task.
 *
 * @public
 */
type TaskCompletionState = 'failed' | 'completed';
/**
 * SerializedTask
 *
 * @public
 */
type SerializedTask = {
    id: string;
    spec: TaskSpec;
    status: TaskStatus;
    createdAt: string;
    lastHeartbeatAt?: string;
    createdBy?: string;
    secrets?: TaskSecrets$1;
};
/**
 * TaskEventType
 *
 * @public
 */
type TaskEventType = 'completion' | 'log' | 'cancelled';
/**
 * SerializedTaskEvent
 *
 * @public
 */
type SerializedTaskEvent = {
    id: number;
    taskId: string;
    body: JsonObject;
    type: TaskEventType;
    createdAt: string;
};
/**
 * The result of {@link TaskBroker.dispatch}
 *
 * @public
 */
type TaskBrokerDispatchResult = {
    taskId: string;
};
/**
 * The options passed to {@link TaskBroker.dispatch}
 * Currently a spec and optional secrets
 *
 * @public
 */
type TaskBrokerDispatchOptions = {
    spec: TaskSpec;
    secrets?: TaskSecrets$1;
    createdBy?: string;
};
/**
 * Task
 *
 * @public
 */
interface TaskContext {
    cancelSignal: AbortSignal;
    spec: TaskSpec;
    secrets?: TaskSecrets$1;
    createdBy?: string;
    done: boolean;
    isDryRun?: boolean;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    getWorkspaceName(): Promise<string>;
}
/**
 * TaskBroker
 *
 * @public
 */
interface TaskBroker {
    cancel?(taskId: string): Promise<void>;
    claim(): Promise<TaskContext>;
    dispatch(options: TaskBrokerDispatchOptions): Promise<TaskBrokerDispatchResult>;
    vacuumTasks(options: {
        timeoutS: number;
    }): Promise<void>;
    event$(options: {
        taskId: string;
        after: number | undefined;
    }): Observable<{
        events: SerializedTaskEvent[];
    }>;
    get(taskId: string): Promise<SerializedTask>;
    list?(options?: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
}
/**
 * TaskStoreEmitOptions
 *
 * @public
 */
type TaskStoreEmitOptions<TBody = JsonObject> = {
    taskId: string;
    body: TBody;
};
/**
 * TaskStoreListEventsOptions
 *
 * @public
 */
type TaskStoreListEventsOptions = {
    taskId: string;
    after?: number | undefined;
};
/**
 * TaskStoreShutDownTaskOptions
 *
 * @public
 */
type TaskStoreShutDownTaskOptions = {
    taskId: string;
};
/**
 * The options passed to {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskOptions = {
    spec: TaskSpec;
    createdBy?: string;
    secrets?: TaskSecrets$1;
};
/**
 * The response from {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskResult = {
    taskId: string;
};
/**
 * TaskStore
 *
 * @public
 */
interface TaskStore {
    cancelTask?(options: TaskStoreEmitOptions): Promise<void>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    getTask(taskId: string): Promise<SerializedTask>;
    claimTask(): Promise<SerializedTask | undefined>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    list?(options: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
    emitLogEvent(options: TaskStoreEmitOptions): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask?(options: TaskStoreShutDownTaskOptions): Promise<void>;
}

/**
 * DatabaseTaskStore
 *
 * @public
 */
type DatabaseTaskStoreOptions = {
    database: PluginDatabaseManager | Knex;
};
/**
 * DatabaseTaskStore
 *
 * @public
 */
declare class DatabaseTaskStore implements TaskStore {
    private readonly db;
    static create(options: DatabaseTaskStoreOptions): Promise<DatabaseTaskStore>;
    private static getClient;
    private static runMigrations;
    private constructor();
    list(options: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
    getTask(taskId: string): Promise<SerializedTask>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    claimTask(): Promise<SerializedTask | undefined>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    emitLogEvent(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask(options: TaskStoreShutDownTaskOptions): Promise<void>;
    cancelTask(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
}

/**
 * TaskManager
 *
 * @public
 */
declare class TaskManager implements TaskContext {
    private readonly task;
    private readonly storage;
    private readonly signal;
    private readonly logger;
    private isDone;
    private heartbeatTimeoutId?;
    static create(task: CurrentClaimedTask, storage: TaskStore, abortSignal: AbortSignal, logger: Logger): TaskManager;
    private constructor();
    get spec(): _backstage_plugin_scaffolder_common.TaskSpecV1beta3;
    get cancelSignal(): AbortSignal;
    get secrets(): TaskSecrets$1 | undefined;
    get createdBy(): string | undefined;
    getWorkspaceName(): Promise<string>;
    get done(): boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    private startTimeout;
}
/**
 * Stores the state of the current claimed task passed to the TaskContext
 *
 * @public
 */
interface CurrentClaimedTask {
    /**
     * The TaskSpec of the current claimed task.
     */
    spec: TaskSpec;
    /**
     * The uuid of the current claimed task.
     */
    taskId: string;
    /**
     * The secrets that are stored with the task.
     */
    secrets?: TaskSecrets$1;
    /**
     * The creator of the task.
     */
    createdBy?: string;
}

/**
 * CreateWorkerOptions
 *
 * @public
 */
type CreateWorkerOptions = {
    taskBroker: TaskBroker;
    actionRegistry: TemplateActionRegistry;
    integrations: ScmIntegrations;
    workingDirectory: string;
    logger: Logger;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    /**
     * The number of tasks that can be executed at the same time by the worker
     * @defaultValue 10
     * @example
     * ```
     * {
     *   concurrentTasksLimit: 1,
     *   // OR
     *   concurrentTasksLimit: Infinity
     * }
     * ```
     */
    concurrentTasksLimit?: number;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
    permissions?: PermissionEvaluator;
};
/**
 * TaskWorker
 *
 * @public
 */
declare class TaskWorker {
    private readonly options;
    private taskQueue;
    private constructor();
    static create(options: CreateWorkerOptions): Promise<TaskWorker>;
    start(): void;
    protected onReadyToClaimTask(): Promise<void>;
    runOneTask(task: TaskContext): Promise<void>;
}

/**
 *
 * @public
 */
type TemplatePermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, TParams>;
/**
 *
 * @public
 */
type ActionPermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_ACTION, TParams>;
/**
 * RouterOptions
 *
 * @public
 */
interface RouterOptions {
    logger: Logger;
    config: Config;
    reader: UrlReader;
    database: PluginDatabaseManager;
    catalogClient: CatalogApi;
    scheduler?: PluginTaskScheduler;
    actions?: TemplateAction$1<any, any>[];
    /**
     * @deprecated taskWorkers is deprecated in favor of concurrentTasksLimit option with a single TaskWorker
     * @defaultValue 1
     */
    taskWorkers?: number;
    /**
     * Sets the number of concurrent tasks that can be run at any given time on the TaskWorker
     * @defaultValue 10
     */
    concurrentTasksLimit?: number;
    taskBroker?: TaskBroker;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
    permissions?: PermissionEvaluator;
    permissionRules?: Array<TemplatePermissionRuleInput | ActionPermissionRuleInput>;
    identity?: IdentityApi;
}
/**
 * A method to create a router for the scaffolder backend plugin.
 * @public
 */
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/** @public */
declare class ScaffolderEntitiesProcessor implements CatalogProcessor {
    getProcessorName(): string;
    private readonly validators;
    validateEntityKind(entity: Entity): Promise<boolean>;
    postProcessEntity(entity: Entity, _location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

/**
 * @public
 * @deprecated Import from {@link @backstage/plugin-scaffolder-node#ActionContext} instead
 */
type ActionContext<TInput extends JsonObject> = ActionContext$1<TInput>;
/**
 * @public
 * @deprecated Use `createTemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
declare const createTemplateAction: <TInputParams extends JsonObject = JsonObject, TOutputParams extends JsonObject = JsonObject, TInputSchema extends zod.ZodType<any, zod.ZodTypeDef, any> | jsonschema.Schema = {}, TOutputSchema extends zod.ZodType<any, zod.ZodTypeDef, any> | jsonschema.Schema = {}, TActionInput extends JsonObject = TInputSchema extends zod.ZodType<any, any, infer IReturn> ? IReturn : TInputParams, TActionOutput extends JsonObject = TOutputSchema extends zod.ZodType<any, any, infer IReturn_1> ? IReturn_1 : TOutputParams>(action: _backstage_plugin_scaffolder_node.TemplateActionOptions<TActionInput, TActionOutput, TInputSchema, TOutputSchema>) => TemplateAction$1<TActionInput, TActionOutput>;
/**
 * @public
 * @deprecated Use `TaskSecrets` from `@backstage/plugin-scaffolder-node` instead
 */
type TaskSecrets = TaskSecrets$1;
/**
 * @public
 * @deprecated Use `TemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
type TemplateAction<TInput extends JsonObject> = TemplateAction$1<TInput>;

export { ActionContext, ActionPermissionRuleInput, CreateBuiltInActionsOptions, CreateGithubPullRequestActionOptions, CreateGithubPullRequestClientFactoryInput, CreateWorkerOptions, CurrentClaimedTask, DatabaseTaskStore, DatabaseTaskStoreOptions, OctokitWithPullRequestPluginClient, RouterOptions, RunCommandOptions, ScaffolderEntitiesProcessor, SerializedTask, SerializedTaskEvent, TaskBroker, TaskBrokerDispatchOptions, TaskBrokerDispatchResult, TaskCompletionState, TaskContext, TaskEventType, TaskManager, TaskSecrets, TaskStatus, TaskStore, TaskStoreCreateTaskOptions, TaskStoreCreateTaskResult, TaskStoreEmitOptions, TaskStoreListEventsOptions, TaskStoreShutDownTaskOptions, TaskWorker, TemplateAction, TemplateActionRegistry, TemplateFilter, TemplateGlobal, TemplatePermissionRuleInput, createBuiltinActions, createCatalogRegisterAction, createCatalogWriteAction, createDebugLogAction, createFetchCatalogEntityAction, createFetchPlainAction, createFetchPlainFileAction, createFetchTemplateAction, createFilesystemDeleteAction, createFilesystemRenameAction, createGithubActionsDispatchAction, createGithubIssuesLabelAction, createGithubRepoCreateAction, createGithubRepoPushAction, createGithubWebhookAction, createPublishAzureAction, createPublishBitbucketAction, createPublishBitbucketCloudAction, createPublishBitbucketServerAction, createPublishGerritAction, createPublishGerritReviewAction, createPublishGithubAction, createPublishGithubPullRequestAction, createPublishGitlabAction, createPublishGitlabMergeRequestAction, createRouter, createTemplateAction, createWaitAction, executeShellCommand, fetchContents };
