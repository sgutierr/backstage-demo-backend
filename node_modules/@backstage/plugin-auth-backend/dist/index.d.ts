/// <reference types="node" />
import express from 'express';
import { Logger } from 'winston';
import { GetEntitiesRequest, CatalogApi } from '@backstage/catalog-client';
import { Entity, UserEntity } from '@backstage/catalog-model';
import { Config } from '@backstage/config';
import { BackstageSignInResult, BackstageIdentityResponse } from '@backstage/plugin-auth-node';
import { JsonValue } from '@backstage/types';
import { Profile } from 'passport';
import { PluginDatabaseManager, PluginEndpointDiscovery, TokenManager } from '@backstage/backend-common';
import { IncomingHttpHeaders } from 'http';
import { TokenSet, UserinfoResponse } from 'openid-client';
import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';

/**
 * Parameters used to issue new ID Tokens
 *
 * @public
 */
type TokenParams = {
    /**
     * The claims that will be embedded within the token. At a minimum, this should include
     * the subject claim, `sub`. It is common to also list entity ownership relations in the
     * `ent` list. Additional claims may also be added at the developer's discretion except
     * for the following list, which will be overwritten by the TokenIssuer: `iss`, `aud`,
     * `iat`, and `exp`. The Backstage team also maintains the right add new claims in the future
     * without listing the change as a "breaking change".
     */
    claims: {
        /** The token subject, i.e. User ID */
        sub: string;
        /** A list of entity references that the user claims ownership through */
        ent?: string[];
    } & Record<string, JsonValue>;
};

/**
 * Common options for passport.js-based OAuth providers
 *
 * @public
 */
type OAuthProviderOptions = {
    /**
     * Client ID of the auth provider.
     */
    clientId: string;
    /**
     * Client Secret of the auth provider.
     */
    clientSecret: string;
    /**
     * Callback URL to be passed to the auth provider to redirect to after the user signs in.
     */
    callbackUrl: string;
};
/** @public */
type OAuthResult = {
    fullProfile: Profile;
    params: {
        id_token?: string;
        scope: string;
        expires_in: number;
    };
    accessToken: string;
    refreshToken?: string;
};
/**
 * The expected response from an OAuth flow.
 *
 * @public
 */
type OAuthResponse = {
    profile: ProfileInfo;
    providerInfo: OAuthProviderInfo;
    backstageIdentity?: BackstageSignInResult;
};
/** @public */
type OAuthProviderInfo = {
    /**
     * An access token issued for the signed in user.
     */
    accessToken: string;
    /**
     * (Optional) Id token issued for the signed in user.
     */
    idToken?: string;
    /**
     * Expiry of the access token in seconds.
     */
    expiresInSeconds?: number;
    /**
     * Scopes granted for the access token.
     */
    scope: string;
};
/** @public */
type OAuthState = {
    nonce: string;
    env: string;
    origin?: string;
    scope?: string;
    redirectUrl?: string;
    flow?: string;
};
/** @public */
type OAuthStartRequest = express.Request<{}> & {
    scope: string;
    state: OAuthState;
};
/** @public */
type OAuthRefreshRequest = express.Request<{}> & {
    scope: string;
    refreshToken: string;
};
/** @public */
type OAuthLogoutRequest = express.Request<{}> & {
    refreshToken: string;
};
/**
 * Any OAuth provider needs to implement this interface which has provider specific
 * handlers for different methods to perform authentication, get access tokens,
 * refresh tokens and perform sign out.
 *
 * @public
 */
interface OAuthHandlers {
    /**
     * Initiate a sign in request with an auth provider.
     */
    start(req: OAuthStartRequest): Promise<OAuthStartResponse>;
    /**
     * Handle the redirect from the auth provider when the user has signed in.
     */
    handler(req: express.Request): Promise<{
        response: OAuthResponse;
        refreshToken?: string;
    }>;
    /**
     * (Optional) Given a refresh token and scope fetches a new access token from the auth provider.
     */
    refresh?(req: OAuthRefreshRequest): Promise<{
        response: OAuthResponse;
        refreshToken?: string;
    }>;
    /**
     * (Optional) Sign out of the auth provider.
     */
    logout?(req: OAuthLogoutRequest): Promise<void>;
}

/**
 * A query for a single user in the catalog.
 *
 * If `entityRef` is used, the default kind is `'User'`.
 *
 * If `annotations` are used, all annotations must be present and
 * match the provided value exactly. Only entities of kind `'User'` will be considered.
 *
 * If `filter` are used they are passed on as they are to the `CatalogApi`.
 *
 * Regardless of the query method, the query must match exactly one entity
 * in the catalog, or an error will be thrown.
 *
 * @public
 */
type AuthResolverCatalogUserQuery = {
    entityRef: string | {
        kind?: string;
        namespace?: string;
        name: string;
    };
} | {
    annotations: Record<string, string>;
} | {
    filter: Exclude<GetEntitiesRequest['filter'], undefined>;
};
/**
 * The context that is used for auth processing.
 *
 * @public
 */
type AuthResolverContext = {
    /**
     * Issues a Backstage token using the provided parameters.
     */
    issueToken(params: TokenParams): Promise<{
        token: string;
    }>;
    /**
     * Finds a single user in the catalog using the provided query.
     *
     * See {@link AuthResolverCatalogUserQuery} for details.
     */
    findCatalogUser(query: AuthResolverCatalogUserQuery): Promise<{
        entity: Entity;
    }>;
    /**
     * Finds a single user in the catalog using the provided query, and then
     * issues an identity for that user using default ownership resolution.
     *
     * See {@link AuthResolverCatalogUserQuery} for details.
     */
    signInWithCatalogUser(query: AuthResolverCatalogUserQuery): Promise<BackstageSignInResult>;
};
/**
 * The callback used to resolve the cookie configuration for auth providers that use cookies.
 * @public
 */
type CookieConfigurer = (ctx: {
    /** ID of the auth provider that this configuration applies to */
    providerId: string;
    /** The externally reachable base URL of the auth-backend plugin */
    baseUrl: string;
    /** The configured callback URL of the auth provider */
    callbackUrl: string;
    /** The origin URL of the app */
    appOrigin: string;
}) => {
    domain: string;
    path: string;
    secure: boolean;
    sameSite?: 'none' | 'lax' | 'strict';
};
/** @public */
type AuthProviderConfig = {
    /**
     * The protocol://domain[:port] where the app is hosted. This is used to construct the
     * callbackURL to redirect to once the user signs in to the auth provider.
     */
    baseUrl: string;
    /**
     * The base URL of the app as provided by app.baseUrl
     */
    appUrl: string;
    /**
     * A function that is called to check whether an origin is allowed to receive the authentication result.
     */
    isOriginAllowed: (origin: string) => boolean;
    /**
     * The function used to resolve cookie configuration based on the auth provider options.
     */
    cookieConfigurer?: CookieConfigurer;
};
/** @public */
type OAuthStartResponse = {
    /**
     * URL to redirect to
     */
    url: string;
    /**
     * Status code to use for the redirect
     */
    status?: number;
};
/**
 * Any Auth provider needs to implement this interface which handles the routes in the
 * auth backend. Any auth API requests from the frontend reaches these methods.
 *
 * The routes in the auth backend API are tied to these methods like below
 *
 * `/auth/[provider]/start -> start`
 * `/auth/[provider]/handler/frame -> frameHandler`
 * `/auth/[provider]/refresh -> refresh`
 * `/auth/[provider]/logout -> logout`
 *
 * @public
 */
interface AuthProviderRouteHandlers {
    /**
     * Handles the start route of the API. This initiates a sign in request with an auth provider.
     *
     * Request
     * - scopes for the auth request (Optional)
     * Response
     * - redirect to the auth provider for the user to sign in or consent.
     * - sets a nonce cookie and also pass the nonce as 'state' query parameter in the redirect request
     */
    start(req: express.Request, res: express.Response): Promise<void>;
    /**
     * Once the user signs in or consents in the OAuth screen, the auth provider redirects to the
     * callbackURL which is handled by this method.
     *
     * Request
     * - to contain a nonce cookie and a 'state' query parameter
     * Response
     * - postMessage to the window with a payload that contains accessToken, expiryInSeconds?, idToken? and scope.
     * - sets a refresh token cookie if the auth provider supports refresh tokens
     */
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    /**
     * (Optional) If the auth provider supports refresh tokens then this method handles
     * requests to get a new access token.
     *
     * Request
     * - to contain a refresh token cookie and scope (Optional) query parameter.
     * Response
     * - payload with accessToken, expiryInSeconds?, idToken?, scope and user profile information.
     */
    refresh?(req: express.Request, res: express.Response): Promise<void>;
    /**
     * (Optional) Handles sign out requests
     *
     * Response
     * - removes the refresh token cookie
     */
    logout?(req: express.Request, res: express.Response): Promise<void>;
}
/** @public */
type AuthProviderFactory = (options: {
    providerId: string;
    globalConfig: AuthProviderConfig;
    config: Config;
    logger: Logger;
    resolverContext: AuthResolverContext;
}) => AuthProviderRouteHandlers;
/** @public */
type AuthResponse<ProviderInfo> = {
    providerInfo: ProviderInfo;
    profile: ProfileInfo;
    backstageIdentity?: BackstageIdentityResponse;
};
/**
 * Used to display login information to user, i.e. sidebar popup.
 *
 * It is also temporarily used as the profile of the signed-in user's Backstage
 * identity, but we want to replace that with data from identity and/org catalog
 * service
 *
 * @public
 */
type ProfileInfo = {
    /**
     * Email ID of the signed in user.
     */
    email?: string;
    /**
     * Display name that can be presented to the signed in user.
     */
    displayName?: string;
    /**
     * URL to an image that can be used as the display image or avatar of the
     * signed in user.
     */
    picture?: string;
};
/**
 * Type of sign in information context. Includes the profile information and
 * authentication result which contains auth related information.
 *
 * @public
 */
type SignInInfo<TAuthResult> = {
    /**
     * The simple profile passed down for use in the frontend.
     */
    profile: ProfileInfo;
    /**
     * The authentication result that was received from the authentication
     * provider.
     */
    result: TAuthResult;
};
/**
 * Describes the function which handles the result of a successful
 * authentication. Must return a valid {@link @backstage/plugin-auth-node#BackstageSignInResult}.
 *
 * @public
 */
type SignInResolver<TAuthResult> = (info: SignInInfo<TAuthResult>, context: AuthResolverContext) => Promise<BackstageSignInResult>;
/**
 * The return type of an authentication handler. Must contain valid profile
 * information.
 *
 * @public
 */
type AuthHandlerResult = {
    profile: ProfileInfo;
};
/**
 * The AuthHandler function is called every time the user authenticates using
 * the provider.
 *
 * The handler should return a profile that represents the session for the user
 * in the frontend.
 *
 * Throwing an error in the function will cause the authentication to fail,
 * making it possible to use this function as a way to limit access to a certain
 * group of users.
 *
 * @public
 */
type AuthHandler<TAuthResult> = (input: TAuthResult, context: AuthResolverContext) => Promise<AuthHandlerResult>;
/** @public */
type StateEncoder = (req: OAuthStartRequest) => Promise<{
    encodedState: string;
}>;

/** @public */
type AwsAlbResult = {
    fullProfile: Profile;
    expiresInSeconds?: number;
    accessToken: string;
};

/** @public */
type EasyAuthResult = {
    fullProfile: Profile;
    accessToken?: string;
};

/** @public */
declare class OAuthEnvironmentHandler implements AuthProviderRouteHandlers {
    private readonly handlers;
    static mapConfig(config: Config, factoryFunc: (envConfig: Config) => AuthProviderRouteHandlers): OAuthEnvironmentHandler;
    constructor(handlers: Map<string, AuthProviderRouteHandlers>);
    start(req: express.Request, res: express.Response): Promise<void>;
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    refresh(req: express.Request, res: express.Response): Promise<void>;
    logout(req: express.Request, res: express.Response): Promise<void>;
    private getRequestFromEnv;
    private getProviderForEnv;
}

/** @public */
type OAuthAdapterOptions = {
    providerId: string;
    persistScopes?: boolean;
    appOrigin: string;
    baseUrl: string;
    cookieConfigurer: CookieConfigurer;
    isOriginAllowed: (origin: string) => boolean;
    callbackUrl: string;
};
/** @public */
declare class OAuthAdapter implements AuthProviderRouteHandlers {
    private readonly handlers;
    private readonly options;
    static fromConfig(config: AuthProviderConfig, handlers: OAuthHandlers, options: Pick<OAuthAdapterOptions, 'providerId' | 'persistScopes' | 'callbackUrl'>): OAuthAdapter;
    private readonly baseCookieOptions;
    constructor(handlers: OAuthHandlers, options: OAuthAdapterOptions);
    start(req: express.Request, res: express.Response): Promise<void>;
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    logout(req: express.Request, res: express.Response): Promise<void>;
    refresh(req: express.Request, res: express.Response): Promise<void>;
    /**
     * If the response from the OAuth provider includes a Backstage identity, we
     * make sure it's populated with all the information we can derive from the user ID.
     */
    private populateIdentity;
    private setNonceCookie;
    private setGrantedScopeCookie;
    private getRefreshTokenFromCookie;
    private getGrantedScopeFromCookie;
    private setRefreshTokenCookie;
    private removeRefreshTokenCookie;
    private getCookieConfig;
}

/** @public */
declare const readState: (stateString: string) => OAuthState;
/** @public */
declare const encodeState: (state: OAuthState) => string;
/** @public */
declare const verifyNonce: (req: express.Request, providerId: string) => void;

/** @public */
type BitbucketOAuthResult = {
    fullProfile: BitbucketPassportProfile;
    params: {
        id_token?: string;
        scope: string;
        expires_in: number;
    };
    accessToken: string;
    refreshToken?: string;
};
/** @public */
type BitbucketPassportProfile = Profile & {
    id?: string;
    displayName?: string;
    username?: string;
    avatarUrl?: string;
    _json?: {
        links?: {
            avatar?: {
                href?: string;
            };
        };
    };
};

/** @public */
type BitbucketServerOAuthResult = {
    fullProfile: Profile;
    params: {
        scope: string;
        access_token?: string;
        token_type?: string;
        expires_in?: number;
    };
    accessToken: string;
    refreshToken?: string;
};

/**
 * CloudflareAccessClaims
 *
 * Can be used in externally provided auth handler or sign in resolver to
 * enrich user profile for sign-in user entity
 *
 * @public
 */
type CloudflareAccessClaims = {
    /**
     * `aud` identifies the application to which the JWT is issued.
     */
    aud: string[];
    /**
     * `email` contains the email address of the authenticated user.
     */
    email: string;
    /**
     * iat and exp are the issuance and expiration timestamps.
     */
    exp: number;
    iat: number;
    /**
     * `nonce` is the session identifier.
     */
    nonce: string;
    /**
     * `identity_nonce` is available in the Application Token and can be used to
     * query all group membership for a given user.
     */
    identity_nonce: string;
    /**
     * `sub` contains the identifier of the authenticated user.
     */
    sub: string;
    /**
     * `iss` the issuer is the applicationâ€™s Cloudflare Access Domain URL.
     */
    iss: string;
    /**
     * `custom` contains SAML attributes in the Application Token specified by an
     * administrator in the identity provider configuration.
     */
    custom: string;
};
/**
 * CloudflareAccessGroup
 *
 * @public
 */
type CloudflareAccessGroup = {
    /**
     * Group id
     */
    id: string;
    /**
     * Name of group as defined in Cloudflare zero trust dashboard
     */
    name: string;
    /**
     * Access group email address
     */
    email: string;
};
/**
 * CloudflareAccessIdentityProfile
 *
 * Can be used in externally provided auth handler or sign in resolver to
 * enrich user profile for sign-in user entity
 *
 * @public
 */
type CloudflareAccessIdentityProfile = {
    id: string;
    name: string;
    email: string;
    groups: CloudflareAccessGroup[];
};
/**
 * @public
 */
type CloudflareAccessResult = {
    claims: CloudflareAccessClaims;
    cfIdentity: CloudflareAccessIdentityProfile;
    expiresInSeconds?: number;
    token: string;
};

/** @public */
type GithubOAuthResult = {
    fullProfile: Profile;
    params: {
        scope: string;
        expires_in?: string;
        refresh_token_expires_in?: string;
    };
    accessToken: string;
    refreshToken?: string;
};

/**
 * JWT header extraction result, containing the raw value and the parsed JWT
 * payload.
 *
 * @public
 */
type OAuth2ProxyResult<JWTPayload = {}> = {
    /**
     * The parsed payload of the `accessToken`. The token is only parsed, not verified.
     *
     * @deprecated Access through the `headers` instead. This will be removed in a future release.
     */
    fullProfile: JWTPayload;
    /**
     * The token received via the X-OAUTH2-PROXY-ID-TOKEN header. Will be an empty string
     * if the header is not set. Note the this is typically an OpenID Connect token.
     *
     * @deprecated Access through the `headers` instead. This will be removed in a future release.
     */
    accessToken: string;
    /**
     * The headers of the incoming request from the OAuth2 proxy. This will include
     * both the headers set by the client as well as the ones added by the OAuth2 proxy.
     * You should only trust the headers that are injected by the OAuth2 proxy.
     *
     * Useful headers to use to complete the sign-in are for example `x-forwarded-user`
     * and `x-forwarded-email`. See the OAuth2 proxy documentation for more information
     * about the available headers and how to enable them. In particular it is possible
     * to forward access and identity tokens, which can be user for additional verification
     * and lookups.
     */
    headers: IncomingHttpHeaders;
    /**
     * Provides convenient access to the request headers.
     *
     * This call is simply forwarded to `req.get(name)`.
     */
    getHeader(name: string): string | undefined;
};

/**
 * authentication result for the OIDC which includes the token set and user information (a profile response sent by OIDC server)
 * @public
 */
type OidcAuthResult = {
    tokenset: TokenSet;
    userinfo: UserinfoResponse;
};

/** @public */
type SamlAuthResult = {
    fullProfile: any;
};

/**
 * The data extracted from an IAP token.
 *
 * @public
 */
type GcpIapTokenInfo = {
    /**
     * The unique, stable identifier for the user.
     */
    sub: string;
    /**
     * User email address.
     */
    email: string;
    /**
     * Other fields.
     */
    [key: string]: JsonValue;
};
/**
 * The result of the initial auth challenge. This is the input to the auth
 * callbacks.
 *
 * @public
 */
type GcpIapResult = {
    /**
     * The data extracted from the IAP token header.
     */
    iapToken: GcpIapTokenInfo;
};

/**
 * All built-in auth provider integrations.
 *
 * @public
 */
declare const providers: Readonly<{
    atlassian: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
    auth0: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
    awsAlb: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<AwsAlbResult> | undefined;
            signIn: {
                resolver: SignInResolver<AwsAlbResult>;
            };
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
    bitbucket: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            usernameMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
            userIdMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    bitbucketServer: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<BitbucketServerOAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<BitbucketServerOAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            emailMatchingUserEntityProfileEmail: () => SignInResolver<BitbucketServerOAuthResult>;
        }>;
    }>;
    cfAccess: Readonly<{
        create: (options: {
            authHandler?: AuthHandler<CloudflareAccessResult> | undefined;
            signIn: {
                resolver: SignInResolver<CloudflareAccessResult>;
            };
            cache?: _backstage_backend_plugin_api.CacheService | undefined;
        }) => AuthProviderFactory;
        resolvers: Readonly<{
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
        }>;
    }>;
    gcpIap: Readonly<{
        create: (options: {
            authHandler?: AuthHandler<GcpIapResult> | undefined;
            signIn: {
                resolver: SignInResolver<GcpIapResult>;
            };
        }) => AuthProviderFactory;
        resolvers: never;
    }>;
    github: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<GithubOAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<GithubOAuthResult>;
            } | undefined;
            stateEncoder?: StateEncoder | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            usernameMatchingUserEntityName: () => SignInResolver<GithubOAuthResult>;
        }>;
    }>;
    gitlab: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
    google: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
            emailMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    microsoft: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
            emailMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    oauth2: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
    oauth2Proxy: Readonly<{
        create: (options: {
            authHandler?: AuthHandler<OAuth2ProxyResult<unknown>> | undefined;
            signIn: {
                resolver: SignInResolver<OAuth2ProxyResult<unknown>>;
            };
        }) => AuthProviderFactory;
        resolvers: never;
    }>;
    oidc: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OidcAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OidcAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
        }>;
    }>;
    okta: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
            emailMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    onelogin: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
    saml: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<SamlAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<SamlAuthResult>;
            } | undefined;
        } | undefined) => AuthProviderFactory;
        resolvers: Readonly<{
            nameIdMatchingUserEntityName(): SignInResolver<SamlAuthResult>;
        }>;
    }>;
    easyAuth: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<EasyAuthResult> | undefined;
            signIn: {
                resolver: SignInResolver<EasyAuthResult>;
            };
        } | undefined) => AuthProviderFactory;
        resolvers: never;
    }>;
}>;
/**
 * All auth provider factories that are installed by default.
 *
 * @public
 */
declare const defaultAuthProviderFactories: {
    [providerId: string]: AuthProviderFactory;
};

/**
 * Creates a standardized representation of an integration with a third-party
 * auth provider.
 *
 * The returned object facilitates the creation of provider instances, and
 * supplies built-in sign-in resolvers for the specific provider.
 *
 * @public
 */
declare function createAuthProviderIntegration<TCreateOptions extends unknown[], TResolvers extends {
    [name in string]: (...args: any[]) => SignInResolver<any>;
}>(config: {
    create: (...args: TCreateOptions) => AuthProviderFactory;
    resolvers?: TResolvers;
}): Readonly<{
    create: (...args: TCreateOptions) => AuthProviderFactory;
    resolvers: Readonly<string extends keyof TResolvers ? never : TResolvers>;
}>;

/**
 * Parses a Backstage-issued token and decorates the
 * {@link @backstage/plugin-auth-node#BackstageIdentityResponse} with identity information sourced from the
 * token.
 *
 * @public
 */
declare function prepareBackstageIdentityResponse(result: BackstageSignInResult): BackstageIdentityResponse;

/** @public */
type ProviderFactories = {
    [s: string]: AuthProviderFactory;
};
/** @public */
interface RouterOptions {
    logger: Logger;
    database: PluginDatabaseManager;
    config: Config;
    discovery: PluginEndpointDiscovery;
    tokenManager: TokenManager;
    tokenFactoryAlgorithm?: string;
    providerFactories?: ProviderFactories;
    catalogApi?: CatalogApi;
}
/** @public */
declare function createRouter(options: RouterOptions): Promise<express.Router>;
/** @public */
declare function createOriginFilter(config: Config): (origin: string) => boolean;

/**
 * Payload sent as a post message after the auth request is complete.
 * If successful then has a valid payload with Auth information else contains an error.
 *
 * @public
 */
type WebMessageResponse = {
    type: 'authorization_response';
    response: AuthResponse<unknown>;
} | {
    type: 'authorization_response';
    error: Error;
};

/** @public */
declare const postMessageResponse: (res: express.Response, appOrigin: string, response: WebMessageResponse) => void;
/** @public */
declare const ensuresXRequestedWith: (req: express.Request) => boolean;

/**
 * A catalog client tailored for reading out identity data from the catalog.
 *
 * @public
 */
declare class CatalogIdentityClient {
    private readonly catalogApi;
    private readonly tokenManager;
    constructor(options: {
        catalogApi: CatalogApi;
        tokenManager: TokenManager;
    });
    /**
     * Looks up a single user using a query.
     *
     * Throws a NotFoundError or ConflictError if 0 or multiple users are found.
     */
    findUser(query: {
        annotations: Record<string, string>;
    }): Promise<UserEntity>;
    /**
     * Resolve additional entity claims from the catalog, using the passed-in entity names. Designed
     * to be used within a `signInResolver` where additional entity claims might be provided, but
     * group membership and transient group membership lean on imported catalog relations.
     *
     * Returns a superset of the entity names that can be passed directly to `issueToken` as `ent`.
     */
    resolveCatalogMembership(query: {
        entityRefs: string[];
        logger?: Logger;
    }): Promise<string[]>;
}

/**
 * Uses the default ownership resolution logic to return an array
 * of entity refs that the provided entity claims ownership through.
 *
 * A reference to the entity itself will also be included in the returned array.
 *
 * @public
 */
declare function getDefaultOwnershipEntityRefs(entity: Entity): string[];

export { AuthHandler, AuthHandlerResult, AuthProviderConfig, AuthProviderFactory, AuthProviderRouteHandlers, AuthResolverCatalogUserQuery, AuthResolverContext, AuthResponse, AwsAlbResult, BitbucketOAuthResult, BitbucketPassportProfile, BitbucketServerOAuthResult, CatalogIdentityClient, CloudflareAccessClaims, CloudflareAccessGroup, CloudflareAccessIdentityProfile, CloudflareAccessResult, CookieConfigurer, EasyAuthResult, GcpIapResult, GcpIapTokenInfo, GithubOAuthResult, OAuth2ProxyResult, OAuthAdapter, OAuthAdapterOptions, OAuthEnvironmentHandler, OAuthHandlers, OAuthLogoutRequest, OAuthProviderInfo, OAuthProviderOptions, OAuthRefreshRequest, OAuthResponse, OAuthResult, OAuthStartRequest, OAuthStartResponse, OAuthState, OidcAuthResult, ProfileInfo, ProviderFactories, RouterOptions, SamlAuthResult, SignInInfo, SignInResolver, StateEncoder, TokenParams, WebMessageResponse, createAuthProviderIntegration, createOriginFilter, createRouter, defaultAuthProviderFactories, encodeState, ensuresXRequestedWith, getDefaultOwnershipEntityRefs, postMessageResponse, prepareBackstageIdentityResponse, providers, readState, verifyNonce };
